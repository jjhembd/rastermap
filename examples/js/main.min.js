var rasterMap = (function (exports) {
  'use strict';

  function initTileCoords( params ) {

    // Initialize position and zoom of the map. All are integers
    var zoom = Math.floor( Math.log2( Math.max(params.nx, params.ny) ) );
    var xTile0 = 0;
    var yTile0 = 0;

    // Transform parameters
    var nTiles = 2 ** zoom;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    function updateTransform() {
      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / params.nx; // Problematic if < 1 ?
      scale[1] = nTiles / params.ny;
    }
    // Initialize transform
    updateTransform();

    return {
      // Info about current map state
      getScale: function(i) { return scale[i]; },
      getZXY,

      // Methods to compute positions within current map
      toLocal,
      xyToMapPixels,
      tileDistance,

      // Methods to update map state
      fitBoundingBox,
      move,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
      return;
    }

    function xyToMapPixels(local, global) {
      toLocal(local, global);
      local[0] *= params.nx * params.tileSize;
      local[1] *= params.ny * params.tileSize;
      return;
    }

    function tileDistance(z, x, y) {
      // Given input tile indices, return a distance metric
      // indicating how far the input tile is from the current map

      // Find edges of tile and map, in units of tiles at current map zoom
      var zoomFac = 2 ** (zoom - z);
      var tile = {
        x1: x * zoomFac,
        x2: (x + 1) * zoomFac,
        y1: y * zoomFac,
        y2: (y + 1) * zoomFac,
      };
      var map = {
        x1: xTile0,
        x2: xTile0 + params.nx + 1, // Note: may extend across antimeridian!
        y1: yTile0,
        y2: yTile0 + params.ny + 1, // Note: may extend across a pole!
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      //             where a "tile" is measured at map zoom level

      // Note: need to be careful with distances crossing an antimeridian or pole
      var xdist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.x1 - tile.x2, tile.x1 - map.x2),
          // Re-test with tile shifted across antimeridian 
          Math.max(map.x1 - (tile.x2 + nTiles), (tile.x1 + nTiles) - map.x2)
          );
      var ydist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.y1 - tile.y2, tile.y1 - map.y2),
          // Re-test with tile shifted across pole 
          Math.max(map.y1 - (tile.y2 + nTiles), (tile.y1 + nTiles) - map.y2)
          );
      // Use the largest distance
      var hdist = Math.max(xdist, ydist);

      // Adjust for zoom difference
      return hdist - 1.0 + 1.0 / zoomFac;
    }

    function toLocal(local, global) {
      // Input global and output local are pointers to 2-element arrays [X,Y]

      // Translate to local origin. Question: should we just use vec2 routines?
      local[0] = global[0] - origin[0];
      local[1] = global[1] - origin[1];

      // Check for wrapping across antimeridian 
      // NOTE: if point is to left of origin, it will be wrapped to right?
      // We might prefer to put it as close as possible to the center
      local[0] = wrap(local[0], 1.0);

      // Scale to the size of the local map
      local[0] *= scale[0];
      local[1] *= scale[1];

      return;
    }

    function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of X/Y coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)
      // TODO: update comment, verify code for non-Mercator projections

      // Remember old values
      var oldZ = zoom;
      var oldX = xTile0;
      var oldY = yTile0;

      // 1. Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.
      // (allows panning to where p1[0] is near the right edge of a tile.)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (gridSize? - 1) / 2 ** zoom > boxSize in both X and Y.
      // BUT we need the minimum zoom to have at least gridSize, i.e.,
      // min zoom = log2(gridSize).
      var zoomX = Math.log2( Math.max(params.nx, (params.nx - 1) / boxWidth) );
      var zoomY = Math.log2( Math.max(params.ny, (params.ny - 1) / boxHeight) );
      zoom = Math.floor( Math.min(zoomX, zoomY) );
      zoom = Math.min(zoom, params.maxZoom);
      nTiles = 2 ** zoom; // Number of tiles at this zoom level

      // 2. Compute the tile indices of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0) * nTiles;
      if (centerX > nTiles) centerX -= nTiles;
      var centerY = 0.5 * (p1[1] + p2[1]) * nTiles;

      // 3. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      xTile0 = Math.round(centerX - params.nx / 2.0);
      xTile0 = wrap(xTile0, nTiles); // in case we crossed the antimeridian
      yTile0 = Math.round(centerY - params.ny / 2.0);
      // Don't let box cross poles
      yTile0 = Math.min(Math.max(0, yTile0), nTiles - params.ny);

      // Return a flag indicating whether map parameters were updated
      if (zoom !== oldZ || xTile0 !== oldX || yTile0 !== oldY) {
        updateTransform();
        return true;
      }
      return false;
    }

    function move(dz, dx, dy) {
      var dzi = Math.round(dz);
      var dxi = Math.round(dx);
      var dyi = Math.round(dy);

      // Don't zoom beyond the limits of the API
      dzi = Math.min(Math.max(0 - zoom, dzi), params.maxZoom - zoom);

      var changed = (dzi || dxi || dyi);

      // Panning first
      xTile0 = wrap(xTile0 + dxi, nTiles);
      yTile0 = wrap(yTile0 + dyi, nTiles);

      while (dzi > 0) {  // Zoom in
        zoom++;
        xTile0 = Math.floor(2 * xTile0 + params.nx / 2.0);
        yTile0 = Math.floor(2 * yTile0 + params.ny / 2.0);
        dzi--;
      }
      while (dzi < 0) {  // Zoom out
        zoom--;
        xTile0 = wrap( Math.ceil( (xTile0 - params.nx / 2.0) / 2 ), nTiles );
        yTile0 = wrap( Math.ceil( (yTile0 - params.ny / 2.0) / 2 ), nTiles );
        dzi++;
      }

      updateTransform();
      return changed;
    }

  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initTileCache(tileAPI) {
    const size = tileAPI.tileSize;

    // Initialize the tiles object
    const tiles = {};

    // Return methods for accessing and updating the tiles
    return {
      retrieve,
      prune,
    };

    function retrieve(tile, zxy) {
      tile.found = false;
      getTileOrParent(tile, zxy[0], zxy[1], zxy[2], 0, 0, size);
      return tile.found;
    }

    function getTileOrParent(
        tileObj,     // Returned tile object
        z, x, y,     // Coordinates of the requested tile
        sx, sy, sw   // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object
      let id = tileAPI.getID(z, x, y);

      // If the tile exists and is ready, return it with cropping info
      if (tiles[id] && tiles[id].complete && tiles[id].naturalWidth !== 0) {
        tileObj.img = tiles[id];
        tileObj.sx = sx;
        tileObj.sy = sy;
        tileObj.sw = sw;
        tileObj.found = true;
        return;
      }

      // Looks like the tile wasn't ready. Try using the parent tile
      if (z > 0 && sw > 1) { // Don't look too far back
        // Get coordinates and cropping parameters of the parent
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        getTileOrParent(tileObj, pz, px, py, psx, psy, psw); // recursive call!
      }

      if (!tiles[id]) {  // Tile didn't exist. Create it and request image from API
        tiles[id] = new Image();
        tiles[id].zoom = z;
        tiles[id].indx = x;
        tiles[id].indy = y;
        tiles[id].crossOrigin = "anonymous";
        tiles[id].src = tileAPI.getURL(id);
      }

      return;
    }

    function prune(metric, threshold) {
      // Remove tiles far from current view (as measured by metric)

      for ( let id in tiles ) {
        let distance = metric(tiles[id].zoom, tiles[id].indx, tiles[id].indy);
        if (distance >= threshold) {
          tiles[id].src = ""; // Cancel any outstanding request (is it necessary?)
          delete tiles[id];
        }
      }
      return;
    }

  }

  function initMap(params, context, coords, tiles) {
    // Resize canvas to fit the specified number of tiles
    const size = params.tileSize;
    const mapWidth = params.nx * size;
    const mapHeight = params.ny * size;
    context.canvas.width = mapWidth;
    context.canvas.height = mapHeight;

    // Initialize tracking object, to check if map needs to be updated
    const dz = [];
    for (let iy = 0; iy < params.ny; iy++) {
      dz[iy] = [];
    }
    const oneTileComplete = 1. / params.nx / params.ny;
    const mapStatus = {
      complete: 0.0,
      dz,
      reset: function() {
        this.complete = 0.0;
        for (let iy = 0; iy < params.ny; iy++) {
          for (let ix = 0; ix < params.nx; ix++) {
            // dz indicates the difference between the requested zoom level
            // and the zoom level actually written to this tile
            dz[iy][ix] = params.maxZoom;
          }
        }
        return;
      },
    };
    mapStatus.reset(); // Initializes dz

    // Return methods for drawing a 2D map
    return {
      loaded: function() {
        return mapStatus.complete;
      },
      drawTiles,
      reset,
    };

    function drawTiles() {
      // Quick exit if map is already complete.
      if ( mapStatus.complete === 1.0 ) return false; // No change!

      var updated = false;
      const tileObj = {};
      const zxy = [];

      // Loop over tiles in the map
      for (let iy = 0; iy < params.ny; iy++) {
        for (let ix = 0; ix < params.nx; ix++) {
          if (mapStatus.dz[iy][ix] === 0) continue; // This tile already done

          coords.getZXY(zxy, ix, iy);
          var foundTile = tiles.retrieve( tileObj, zxy );
          if (!foundTile) continue; // No image available for this tile
          var dzTmp = zxy[0] - tileObj.img.zoom;
          if (dzTmp == mapStatus.dz[iy][ix]) continue; // Tile already written

          context.drawImage(
              tileObj.img,    // Image to read, and paint to the canvas
              tileObj.sx,     // First x-pixel in tile to read
              tileObj.sy,     // First y-pixel in tile to read
              tileObj.sw,     // Number of pixels to read in x
              tileObj.sw,     // Number of pixels to read in y
              ix * size,      // First x-pixel in canvas to paint
              iy * size,      // First y-pixel in canvas to paint
              size,           // Number of pixels to paint in x
              size            // Number of pixels to paint in y
              );
          updated = true;

          if (dzTmp == 0) mapStatus.complete += oneTileComplete;
          mapStatus.dz[iy][ix] = dzTmp;
        }
      }
      return updated;
    }

    function reset() {
      mapStatus.reset();
      context.clearRect(0, 0, mapWidth, mapHeight);
      return;
    }
  }

  function initBoxQC(overlay, coords, width, height) {

    // Resize canvases to fit the specified number of tiles
    overlay.canvas.width = width;
    overlay.canvas.height = height;

    // Track status of bounding box for QC
    const boxQC = [ [0,0], [0,0] ];
    const pixQC = [ [0,0], [0,0] ];

    // Return methods for drawing the QC
    return {
      draw,
      reset,
    };

    function draw(p1, p2, mapChanged) {
      // Check if bounding box changed since last call
      var boxChanged = updateBox(boxQC, [p1, p2]);
      if (!boxChanged && !mapChanged) return;

      // Special case: box moved but map didn't
      if (!mapChanged) overlay.clearRect(0, 0, width, height);

      // Convert box to map pixels
      coords.xyToMapPixels( pixQC[0], boxQC[0] );
      coords.xyToMapPixels( pixQC[1], boxQC[1] );

      // Draw bounding box on overlay
      overlay.strokeStyle = "#FF0000";
      overlay.lineWidth = 5;
      overlay.strokeRect(
          pixQC[0][0],
          pixQC[0][1],
          pixQC[1][0] - pixQC[0][0],
          pixQC[1][1] - pixQC[0][1]
          );

      return;
    }

    function updateBox(bOld, bNew) {
      var same = (
          bNew[0][0] === bOld[0][0] &&
          bNew[0][1] === bOld[0][1] &&
          bNew[1][0] === bOld[1][0] &&
          bNew[1][1] === bOld[1][1]
          );
      if (same) return false;

      // Box changed. Do a deep copy
      bOld[0][0] = bNew[0][0];
      bOld[0][1] = bNew[0][1];
      bOld[1][0] = bNew[1][0];
      bOld[1][1] = bNew[1][1];
      return true;
    }

    function reset() {
      overlay.clearRect(0, 0, width, height);
      boxQC[0][0] = 0;
      boxQC[0][1] = 0;
      boxQC[1][0] = 0;
      boxQC[1][1] = 0;
      return;
    }
  }

  function init(params, context, overlay) {
    // Check if we have a valid canvas rendering context
    var haveRaster = context instanceof CanvasRenderingContext2D;
    if (!haveRaster) {
      console.log("WARNING in rastermap.init: not a 2D rendering context!");
      //return false;
    }

    // Compute pixel size of map
    const mapWidth = params.nx * params.tileSize;
    const mapHeight = params.ny * params.tileSize;
    console.log("map size: " + mapWidth + "x" + mapHeight);

    // Setup tile coordinates and tile cache
    const coords = initTileCoords( params );
    const tiles = initTileCache( params );

    // Initialize grid of rendered tiles
    const map = initMap(params, context, coords, tiles);

    // Initialize bounding box QC overlay
    var boxQC;
    var haveVector = overlay instanceof CanvasRenderingContext2D;
    if (haveVector) {
      boxQC = initBoxQC(overlay, coords, mapWidth, mapHeight);
    }

    // Return methods for drawing a 2D map
    return {
      drawTiles,
      loaded: map.loaded,
      move: function(dz, dx, dy) {
        var changed = coords.move(dz, dx, dy);
        if (changed) reset();
      },
      fitBoundingBox,
      toLocal: coords.toLocal,
      getScale: coords.getScale,
      xyToMapPixels: coords.xyToMapPixels,
    };

    function fitBoundingBox(p1, p2) {
      var mapChanged = coords.fitBoundingBox(p1, p2);
      if (mapChanged) reset();
      if (haveVector) boxQC.draw(p1, p2, mapChanged);
      return;
    }

    function drawTiles() {
      var updated = map.drawTiles();
      // Clean up -- don't let images object get too big
      tiles.prune(coords.tileDistance, 3.5);
      return updated;
    }

    function reset() {
      map.reset();
      if (haveVector) boxQC.reset();
      return;
    }
  }

  const params = Object.freeze({
    // Root URL and token for accessing the REST API
    baseURL: "https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/",
    token: "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA",
    
    // Number of zoom levels
    maxZoom: 20,
    
    // Width of a tile in pixels (ASSUMES square tiles)
    tileSize: 256,
    
    // Specify number of tiles in the map, in each direction
    nx: 4,
    ny: 3,
    
    // Specify how to get the unique ID of a tile, given its zoom and x/y indices
    getID: function(zoom, x, y) {
      return "/" + zoom + "/" + x + "/" + y + "/";
    },
    
    // Specify how to construct the URL for a given tile, from its unique ID
    getURL: function(id) {
      return this.baseURL + this.tileSize + id + "?access_token=" + this.token;
    },
  });

  // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
  const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

  function lonLatToXY(projected, geodetic) {
    // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
    // longitude and latitude of a point on the ellipsoid surface
    // Output projected is a pointer to a 2-element array containing
    // the projected X/Y coordinates

    projected[0] = lonToX( geodetic[0] );
    projected[1] = latToY( geodetic[1] );
    return;
  }

  function lonToX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
    var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);
    var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
    Math.log( Math.tan(Math.PI / 4.0 + clipLat / 2.0) );
    // Clip range to [0,1], since y does not wrap around
    return Math.min(Math.max(0.0, y), 1.0);
  }

  function main() {
    // Setup 2D map
    const display = document.getElementById("rasterCanvas").getContext("2d");
    const overlay = document.getElementById("vectorCanvas").getContext("2d");
    const map = init(params, display, overlay);

    // Handle a supplied bounding box
    var westDeg = document.getElementById("west");
    var eastDeg = document.getElementById("east");
    var northDeg = document.getElementById("north");
    var southDeg = document.getElementById("south");
    var bboxSet = document.getElementById("bboxSet");
    bboxSet.addEventListener("click", function(click) {
      var p1 = [];
      lonLatToXY( p1, 
          [toRadians(westDeg.value), toRadians(northDeg.value)] );
      var p2 = [];
      lonLatToXY( p2,
          [toRadians(eastDeg.value), toRadians(southDeg.value)] );
      map.fitBoundingBox(p1, p2);
    }, false);

    function toRadians(degrees) {
      return degrees * Math.PI / 180.0;
    }
    // Setup panning controls
    var up = document.getElementById("up");
    up.addEventListener("click", function(click) { map.move(0, 0, -1); }, false);
    var down = document.getElementById("down");
    down.addEventListener("click", function(click) { map.move(0, 0, 1); }, false);
    var left = document.getElementById("left");
    left.addEventListener("click", function(click) { map.move(0, -1, 0); }, false);
    var right = document.getElementById("right");
    right.addEventListener("click", function(click) { map.move(0, 1, 0); }, false);

    // Setup zoom controls
    var zoomIn = document.getElementById("zoomIn");
    zoomIn.addEventListener("click", function(click) { map.move(1, 0, 0); }, false);
    var zoomOut = document.getElementById("zoomOut");
    zoomOut.addEventListener("click", function(click) { map.move(-1, 0, 0); }, false);

    // Track loading status
    var loaded = document.getElementById("completion");
    // Start animation loop
    requestAnimationFrame(checkRender);
    function checkRender(time) {
      map.drawTiles();
      var percent = map.loaded() * 100;
      if (percent < 100) {
        loaded.innerHTML = "Loading: " + percent.toFixed(0) + "%";
      } else {
        loaded.innerHTML = "Complete! " + percent.toFixed(0) + "%";
      }
      requestAnimationFrame(checkRender);
    }
  }

  exports.main = main;

  return exports;

}({}));
