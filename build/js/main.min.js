var rasterMap = (function (exports) {
  'use strict';

  function initTileCoords( tileAPI, projection ) {
    // Store parameters of the map tiles API
    const tileSize = tileAPI.tileSize;
    const maxZoom = tileAPI.maxZoom;

    // Dimensions of our working set of tiles
    const numTiles = Object.freeze({ x: 4, y: 3 });

    // Working variables to track camera position within the texture
    const camMapPos = new Float32Array(4); // [x, y, xscale, yscale]

    // Initialize position and zoom of the map. All are integers
    // Note: the case (numTiles.x != numTiles.y) is not yet well understood
    var zoom = Math.floor( Math.log2( Math.max(numTiles.x, numTiles.y) ) );
    var xTile0 = 0;
    var yTile0 = 0;

    // Transform parameters
    var nTiles = 2 ** zoom;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    function updateTransform() {
      nTiles = 2 ** zoom;
      // pan actions may have pushed us across an antimeridian or pole
      xTile0 = wrap(xTile0, nTiles);
      yTile0 = wrap(yTile0, nTiles);

      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / numTiles.x; // Problematic if < 1 ?
      scale[1] = nTiles / numTiles.y;
    }
    // Initialize transform
    updateTransform();

    return {
      // Info about current camera position and map state
      camMapPos,
      // NOTE: functions prevent update of z/x/y from outside
      zoom: function() { return zoom },
      xTile0: function() { return xTile0 },
      yTile0: function() { return yTile0 },
      nTiles: function() { return nTiles },
      numTiles,

      // Methods to compute positions within current map
      updateCamMapPos,
      xyToMapPixels,
      tileDistance,

      // Methods to update map state
      fitBoundingBox,
      pan,
      zoomIn,
      zoomOut,
    };

    function updateCamMapPos( position ) {
      // Input position is a pointer to a 3-element array, containing the
      // longitude, latitude, and altitude of the camera
      
      // Project lon/lat to global x/y  TODO: move this out?
      const projected = [0,0];
      projection.lonLatToXY(projected, position);

      // Transform global to local map coordinates
      toLocal(camMapPos, projected);

      // Add scaling information
      camMapPos[2] = scale[0];
      camMapPos[3] = scale[1];

      // Set projection-related parameters for shader  TODO: move this out
      projection.setShaderParams(position[1]);

      return;
    }

    function xyToMapPixels(webMercX, webMercY) {
      // Convert input point to fractional number of tiles from xTile0, yTile0
      const local = [0,0];
      // TODO: input as vector
      toLocal(local, [webMercX, webMercY]);
      local[0] *= numTiles.x * tileSize;
      local[1] *= numTiles.y * tileSize;

      return local;
    }

    function tileDistance(z, x, y) {
      // Given input tile indices, return a distance metric
      // indicating how far the input tile is from the current map

      // Find edges of tile and map, in units of tiles at current map zoom
      var zoomFac = 2 ** (zoom - z);
      var tile = {
        x1: x * zoomFac,
        x2: (x + 1) * zoomFac,
        y1: y * zoomFac,
        y2: (y + 1) * zoomFac,
      };
      var map = {
        x1: xTile0,
        x2: xTile0 + numTiles.x + 1, // Note: may extend across antimeridian!
        y1: yTile0,
        y2: yTile0 + numTiles.y + 1, // Note: may extend across a pole!
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      //             where a "tile" is measured at map zoom level

      // Note: need to be careful with distances crossing an antimeridian or pole
      var xdist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.x1 - tile.x2, tile.x1 - map.x2),
          // Re-test with tile shifted across antimeridian 
          Math.max(map.x1 - (tile.x2 + nTiles), (tile.x1 + nTiles) - map.x2)
          );
      var ydist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.y1 - tile.y2, tile.y1 - map.y2),
          // Re-test with tile shifted across pole 
          Math.max(map.y1 - (tile.y2 + nTiles), (tile.y1 + nTiles) - map.y2)
          );
      // Use the largest distance
      var hdist = Math.max(xdist, ydist);

      // Adjust for zoom difference
      return hdist - 1.0 + 1.0 / zoomFac;
    }

    function toLocal(local, global) {
      // Input global and output local are pointers to 2-element arrays [X,Y]

      // Translate to local origin. Question: should we just use vec2 routines?
      local[0] = global[0] - origin[0];
      local[1] = global[1] - origin[1];

      // Check for wrapping across antimeridian 
      // NOTE: if point is to left of origin, it will be wrapped to right?
      // We might prefer to put it as close as possible to the center
      local[0] = wrap(local[0], 1.0);

      // Scale to the size of the local map
      local[0] *= scale[0];
      local[1] *= scale[1];

      return;
    }

    function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of Web Mercator coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)

      // Remember old values
      var oldZ = zoom;
      var oldX = xTile0;
      var oldY = yTile0;

      // 1. Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within numTiles - 1.
      // (allows panning to where p1[0] is near the right edge of a tile.)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (numTiles? - 1) / 2 ** zoom > boxSize in both X and Y.
      // BUT we need the minimum zoom to have at least numTiles, i.e.,
      // min zoom = log2(numTiles).
      var zoomX = Math.log2( Math.max(numTiles.x, (numTiles.x - 1) / boxWidth) );
      var zoomY = Math.log2( Math.max(numTiles.y, (numTiles.y - 1) / boxHeight) );
      zoom = Math.floor( Math.min(zoomX, zoomY) );
      zoom = Math.min(zoom, maxZoom);
      nTiles = 2 ** zoom; // Number of tiles at this zoom level

      // 2. Compute the tile indices of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0) * nTiles;
      if (centerX > nTiles) centerX -= nTiles;
      var centerY = 0.5 * (p1[1] + p2[1]) * nTiles;

      // 3. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      xTile0 = Math.round(centerX - numTiles.x / 2.0);
      xTile0 = wrap(xTile0, nTiles); // in case we crossed the antimeridian
      yTile0 = Math.round(centerY - numTiles.y / 2.0);
      // Don't let box cross poles
      yTile0 = Math.min(Math.max(0, yTile0), nTiles - numTiles.y);

      // Return a flag indicating whether map parameters were updated
      if (zoom !== oldZ || xTile0 !== oldX || yTile0 !== oldY) {
        updateTransform();
        return true;
      }
      return false;
    }

    function pan(dx, dy) {
      xTile0 += dx;
      yTile0 += dy;
      updateTransform();
      return (dx || dy);
    }

    function zoomIn() {
      if (zoom >= maxZoom) return false;
      zoom++;
      xTile0 = Math.floor(2 * xTile0 + numTiles.x / 2.0);
      yTile0 = Math.floor(2 * yTile0 + numTiles.y / 2.0);
      updateTransform();
      return true;
    }

    function zoomOut() {
      if (zoom <= 0) return false;
      zoom--;
      xTile0 = Math.ceil( (xTile0 - numTiles.x / 2.0) / 2 );
      yTile0 = Math.ceil( (yTile0 - numTiles.y / 2.0) / 2 );
      updateTransform();
      return true;
    }

  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initTiles(tileCoords, tileAPI, display) {

    const mapWidth = tileCoords.numTiles.x * tileAPI.tileSize;
    const mapHeight = tileCoords.numTiles.y * tileAPI.tileSize;

    // Initialize images object to store a cache of map tiles
    const images = {};

    // Initialize tracking object, to check if map needs to be updated
    const dz = [];
    for (let iy = 0; iy < tileCoords.numTiles.y; iy++) {
      dz[iy] = [];
      for (let ix = 0; ix < tileCoords.numTiles.x; ix++) {
        // dz indicates the difference between the requested zoom level
        // and the zoom level actually written to this tile
        dz[iy][ix] = tileAPI.maxZoom;
      }
    }
    const oneTileComplete = 1. / tileCoords.numTiles.x / tileCoords.numTiles.y;
    const mapStatus = {
      zoom: 0,
      xTile0: 0,
      yTile0: 0,
      complete: 0.0,
      dz,
      changed: function() {
        return (this.zoom !== tileCoords.zoom()  ||
            this.xTile0 !== tileCoords.xTile0()  ||
            this.yTile0 !== tileCoords.yTile0()  );
      },
      reset: function() {
        this.zoom = tileCoords.zoom();
        this.xTile0 = tileCoords.xTile0();
        this.yTile0 = tileCoords.yTile0();
        this.complete = 0.0;
        for (let iy = 0; iy < tileCoords.numTiles.y; iy++) {
          for (let ix = 0; ix < tileCoords.numTiles.x; ix++) {
            dz[iy][ix] = tileAPI.maxZoom;
          }
        }
        return;
      },
    };

    // Return methods for drawing a 2D map
    return {
      drawTiles,
      loaded: function () {
        return mapStatus.complete;
      },
    };

    function drawTiles() {
      if ( mapStatus.changed() ) {
        // Position or zoom of map has changed. Reset status
        mapStatus.reset();
        // Clear current canvases
        display.clearRect(0, 0, mapWidth, mapHeight);
      }

      // Quick exit if map is already complete.
      if ( mapStatus.complete === 1.0 ) return false; // No change!

      // Loop over tiles in the map
      for (let iy = 0; iy < tileCoords.numTiles.y; iy++) {
        let y = wrap$1( tileCoords.yTile0() + iy, tileCoords.nTiles() );

        for (let ix = 0; ix < tileCoords.numTiles.x; ix++) {
          if (mapStatus.dz[iy][ix] === 0) continue; // This tile already done

          let x = wrap$1( tileCoords.xTile0() + ix, tileCoords.nTiles() );

          mapStatus.dz[iy][ix] = drawTile(display, ix, iy, images, tileAPI,
              tileCoords.zoom(), x, y, 0, 0, tileAPI.tileSize);

          if (mapStatus.dz[iy][ix] == 0) mapStatus.complete += oneTileComplete;
        }
      }
      // Clean up -- don't let images object get too big
      prune(images, tileCoords);
      // TODO: if we are waiting a long time for a tile to load,
      // the map will continuously update.
      // The stuck tile will be continually rewritten with the parent tile.
      return true; // Map has updated or is not yet complete
    }
  }

  function drawTile(
      ctx,         // 2D canvas context, to which the tile will be drawn
      ix, iy,      // Indices of which tile in the canvas to update
      tiles,       // Array of image objects
      tileAPI,     // API info of the tile service
      z, x, y,     // Coordinates of the tile in the API to be read
      sx, sy, sw   // Cropping parameters--which part of the tile to use
      // Return value indicates the number of zoom levels between the requested
      // zoom and the zoom actually written. Return = 0 means tile is complete.
      // TODO: return without drawing if the closest zoom level available is
      // the same as what is already written
      ) {

    // Retrieve the specified tile from the tiles object
    let tileID = tileAPI.getID(z, x, y);
    let tile = tiles[tileID];
    let size = tileAPI.tileSize;

    // If the tile exists and is ready, write it to the canvas
    if (tile && tile.complete && tile.naturalWidth !== 0) {
      //console.log("drawTile: ix, iy, z, x, y, sx, sy, sw = " + ix + ", " + iy + 
      //    ", " + z + ", " + x + ", " + y + ", " + sx + ", " + sy + ", " + sw);
      ctx.drawImage(
          tile,      // Image to read, and paint to the canvas
          sx,        // First x-pixel in tile to read
          sy,        // First y-pixel in tile to read
          sw,        // Number of pixels to read in x
          sw,        // Number of pixels to read in y
          ix * size, // First x-pixel in canvas to paint
          iy * size, // First y-pixel in canvas to paint
          size,      // Number of pixels to paint in x
          size,      // Number of pixels to paint in y
          );
      //if (sw < tileAPI.tileSize) throw ("drew a parent");
      return 0; // Success! We wrote the requested resolution
    }

    // Looks like the tile wasn't ready. Try using the parent tile
    // Track the number of generations we go back before finding a live tile
    var generations = 1;
    if (z > 0 && sw > 1) { // Don't look too far back
      // Get coordinates and cropping parameters of the parent
      let pz = z - 1;
      let px = Math.floor(x / 2);
      let py = Math.floor(y / 2);
      let psx = sx / 2 + (x / 2 - px) * size;
      let psy = sy / 2 + (y / 2 - py) * size;
      let psw = sw / 2;

      // Note: recursive function call!
      generations += drawTile(ctx, ix, iy, tiles, tileAPI,
          pz, px, py, psx, psy, psw);
    }

    if (!tile) {  // Tile didn't even exist. Create it and request image
      //console.log("drawTile: # tiles = " + Object.keys(tiles).length +
      //    ".  Adding tile " + tileID);
      tile = new Image();
      tile.zoom = z;
      tile.indx = x;
      tile.indy = y;
      tile.crossOrigin = "anonymous";
      tile.src = tileAPI.getURL(tileID);
      tiles[tileID] = tile;
    }

    return generations;
  }

  function prune(tiles, coords) {
    // Remove tiles far from current view ('far' and 'view' defined in coords)
    
    for ( let id in tiles ) {
      //console.log("prune: checking tile " + id);
      let distance = coords.tileDistance(
          tiles[id].zoom,
          tiles[id].indx,
          tiles[id].indy
          );
      if (distance >= 3.0) {
        //console.log("prune: tile " + id + " distance=" + distance);
        // Cancel any outstanding request
        tiles[id].src = "";
        // Delete all data for this tile
        delete tiles[id];
      }
    }
    return;
  }

  function wrap$1(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initMap2D(display, overlay, tileAPI, projection) {
    // Setup tile coordinates  TODO: tileAPI should include projection?
    const tileCoords = initTileCoords( tileAPI, projection );

    // Set canvas drawing buffer size equal to the CSS displayed size
    const mapWidth = tileCoords.numTiles.x * tileAPI.tileSize;
    const mapHeight = tileCoords.numTiles.y * tileAPI.tileSize;
    display.canvas.width = mapWidth;
    display.canvas.height = mapHeight;
    overlay.canvas.width = mapWidth;
    overlay.canvas.height = mapHeight;
    console.log("display size: " + mapWidth + "x" + mapHeight);

    const tiles = initTiles(tileCoords, tileAPI, display);

    // Return methods for drawing a 2D map
    return {
      drawTiles: tiles.drawTiles,
      pan: tileCoords.pan,
      zoomIn: tileCoords.zoomIn,
      zoomOut: tileCoords.zoomOut,
      fitBoundingBox: tileCoords.fitBoundingBox,
      loaded: tiles.loaded,
    };

  }

  const params = {
    baseURL: "https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/",
    token: "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA",
    tileSize: 256, //512,
    maxZoom: 20,
    getID: function(zoom, x, y) {
      return "/" + zoom + "/" + x + "/" + y + "/";
    },
    getURL: function(id) {
      return this.baseURL + this.tileSize + id + "?access_token=" + this.token;
    },
  };
  // Export as read-only
  const tileAPI = Object.freeze(params);

  function initMercator() {
    // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
    const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

    const shaderParams = new Float64Array(2);

    return {
      lonLatToXY,
      lonToX,
      latToY,
      setShaderParams,
      shaderParams,
    };

    function setShaderParams(lat) {
      // Clip latitude to map boundaries
      var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);

      // camera exp(Y), for converting delta latitude to delta Y
      shaderParams[0] = Math.tan( 0.25 * Math.PI + 0.5 * clipLat );

      // Difference of clipping
      shaderParams[1] = lat - clipLat;
      return;
    }

    function lonLatToXY(projected, geodetic) {
      // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
      // longitude and latitude of a point on the ellipsoid surface
      // Output projected is a pointer to a 2-element array containing
      // the projected X/Y coordinates

      projected[0] = lonToX( geodetic[0] );
      projected[1] = latToY( geodetic[1] );
      return;
    }

    function lonToX(lon) {
      // Convert input longitude in radians to a Web Mercator x-coordinate
      // where x = 0 at lon = -PI, x = 1 at lon = +PI
      return 0.5 + 0.5 * lon / Math.PI;
    }

    function latToY(lat) {
      // Convert input latitude in radians to a Web Mercator y-coordinate
      // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
      var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);
      var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
        Math.log( Math.tan(Math.PI / 4.0 + clipLat / 2.0) );
      // Clip range to [0,1], since y does not wrap around
      return Math.min(Math.max(0.0, y), 1.0);
    }
  }

  function main() {
    // Setup 2D map
    const display = document.getElementById("rasterCanvas").getContext("2d");
    const overlay = document.getElementById("vectorCanvas").getContext("2d");
    const projection = initMercator();
    const map = initMap2D(display, overlay, tileAPI, projection);

    // Handle a supplied bounding box
    var westDeg = document.getElementById("west");
    var eastDeg = document.getElementById("east");
    var northDeg = document.getElementById("north");
    var southDeg = document.getElementById("south");
    var bboxSet = document.getElementById("bboxSet");
    bboxSet.addEventListener("click", function(click) {
      var p1 = [
        projection.lonToWebMercX( toRadians(westDeg.value) ),
        projection.latToWebMercY( toRadians(northDeg.value) )
      ];
      var p2 = [
        projection.lonToWebMercX( toRadians(eastDeg.value) ),
        projection.latToWebMercY( toRadians(southDeg.value) )
      ];
      map.fitBoundingBox(p1, p2);
    }, false);

    function toRadians(degrees) {
      return degrees * Math.PI / 180.0;
    }
    // Setup panning controls
    var up = document.getElementById("up");
    up.addEventListener("click", function(click) { map.pan(0, -1); }, false);
    var down = document.getElementById("down");
    down.addEventListener("click", function(click) { map.pan(0, 1); }, false);
    var left = document.getElementById("left");
    left.addEventListener("click", function(click) { map.pan(-1, 0); }, false);
    var right = document.getElementById("right");
    right.addEventListener("click", function(click) { map.pan(1, 0); }, false);

    // Setup zoom controls
    var zoomIn = document.getElementById("zoomIn");
    zoomIn.addEventListener("click", function(click) { map.zoomIn(); }, false);
    var zoomOut = document.getElementById("zoomOut");
    zoomOut.addEventListener("click", function(click) { map.zoomOut(); }, false);

    // Track loading status
    var loaded = document.getElementById("completion");
    // Start animation loop
    requestAnimationFrame(checkRender);
    function checkRender(time) {
      map.drawTiles();
      var percent = map.loaded() * 100;
      if (percent < 100) {
        loaded.innerHTML = "Loading: " + percent.toFixed(0) + "%";
      } else {
        loaded.innerHTML = "Complete! " + percent.toFixed(0) + "%";
      }
      requestAnimationFrame(checkRender);
    }
  }

  exports.main = main;

  return exports;

}({}));
