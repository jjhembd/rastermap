var rasterMap = (function (exports) {
  'use strict';

  function initTileCoords( tileAPI, projection ) {
    // Store parameters of the map tiles API
    const tileSize = tileAPI.tileSize;
    const maxZoom = tileAPI.maxZoom;

    // Dimensions of our working set of tiles
    const gridSize = Object.freeze({ x: 4, y: 3 });

    // Working variables to track camera position within the texture
    const camMapPos = new Float32Array(4); // [x, y, xscale, yscale]

    // Initialize position and zoom of the map. All are integers
    var zoom = Math.floor( Math.log2( Math.max(gridSize.x, gridSize.y) ) );
    var xTile0 = 0;
    var yTile0 = 0;

    // Transform parameters
    var nTiles = 2 ** zoom;
    const origin = new Float64Array(2);
    const scale = new Float64Array(2);

    function updateTransform() {
      nTiles = 2 ** zoom;
      origin[0] = xTile0 / nTiles;
      origin[1] = yTile0 / nTiles;
      scale[0] = nTiles / gridSize.x; // Problematic if < 1 ?
      scale[1] = nTiles / gridSize.y;
    }
    // Initialize transform
    updateTransform();

    return {
      // Info about current camera position and map state
      camMapPos,
      getZXY,
      gridSize,

      // Methods to compute positions within current map
      updateCamMapPos,
      xyToMapPixels,
      tileDistance,

      // Methods to update map state
      fitBoundingBox,
      pan,
      zoomIn,
      zoomOut,
    };

    function getZXY(zxy, ix, iy) {
      // Report the ZXY of a given tile within the grid
      zxy[0] = zoom;
      zxy[1] = wrap(xTile0 + ix, nTiles);
      zxy[2] = wrap(yTile0 + iy, nTiles);
    }

    function updateCamMapPos( position ) {
      // Input position is a pointer to a 3-element array, containing the
      // longitude, latitude, and altitude of the camera
      
      // Project lon/lat to global x/y  TODO: move this out?
      const projected = [0,0];
      projection.lonLatToXY(projected, position);

      // Transform global to local map coordinates
      toLocal(camMapPos, projected);

      // Add scaling information
      camMapPos[2] = scale[0];
      camMapPos[3] = scale[1];

      // Set projection-related parameters for shader  TODO: move this out
      projection.setShaderParams(position[1]);

      return;
    }

    function xyToMapPixels(webMercX, webMercY) {
      // Convert input point to fractional number of tiles from xTile0, yTile0
      const local = [0,0];
      // TODO: input as vector
      toLocal(local, [webMercX, webMercY]);
      local[0] *= gridSize.x * tileSize;
      local[1] *= gridSize.y * tileSize;

      return local;
    }

    function tileDistance(z, x, y) {
      // Given input tile indices, return a distance metric
      // indicating how far the input tile is from the current map

      // Find edges of tile and map, in units of tiles at current map zoom
      var zoomFac = 2 ** (zoom - z);
      var tile = {
        x1: x * zoomFac,
        x2: (x + 1) * zoomFac,
        y1: y * zoomFac,
        y2: (y + 1) * zoomFac,
      };
      var map = {
        x1: xTile0,
        x2: xTile0 + gridSize.x + 1, // Note: may extend across antimeridian!
        y1: yTile0,
        y2: yTile0 + gridSize.y + 1, // Note: may extend across a pole!
      };

      // Find horizontal distance between current tile and edges of current map
      //  hdist < 0: part of input tile is within map
      //  hdist = 0: tile edge touches edge of map
      //  hdist = n: tile edge is n tiles away from edge of map,
      //             where a "tile" is measured at map zoom level

      // Note: need to be careful with distances crossing an antimeridian or pole
      var xdist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.x1 - tile.x2, tile.x1 - map.x2),
          // Re-test with tile shifted across antimeridian 
          Math.max(map.x1 - (tile.x2 + nTiles), (tile.x1 + nTiles) - map.x2)
          );
      var ydist = Math.min(
          // Test for non-intersection with tile in raw position
          Math.max(map.y1 - tile.y2, tile.y1 - map.y2),
          // Re-test with tile shifted across pole 
          Math.max(map.y1 - (tile.y2 + nTiles), (tile.y1 + nTiles) - map.y2)
          );
      // Use the largest distance
      var hdist = Math.max(xdist, ydist);

      // Adjust for zoom difference
      return hdist - 1.0 + 1.0 / zoomFac;
    }

    function toLocal(local, global) {
      // Input global and output local are pointers to 2-element arrays [X,Y]

      // Translate to local origin. Question: should we just use vec2 routines?
      local[0] = global[0] - origin[0];
      local[1] = global[1] - origin[1];

      // Check for wrapping across antimeridian 
      // NOTE: if point is to left of origin, it will be wrapped to right?
      // We might prefer to put it as close as possible to the center
      local[0] = wrap(local[0], 1.0);

      // Scale to the size of the local map
      local[0] *= scale[0];
      local[1] *= scale[1];

      return;
    }

    function fitBoundingBox(p1, p2) {
      // Inputs p1, p2 are 2D arrays containing pairs of Web Mercator coordinates
      // in the range [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES p2 is SouthEast of p1 although we may have p2[0] < p1[0]
      // if the box crosses the antimeridian (longitude = +/- PI)

      // Remember old values
      var oldZ = zoom;
      var oldX = xTile0;
      var oldY = yTile0;

      // 1. Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within gridSize - 1.
      // (allows panning to where p1[0] is near the right edge of a tile.)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = p2[0] - p1[0];
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      var boxHeight = p2[1] - p1[1];
      if (boxHeight < 0) return false;

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (gridSize? - 1) / 2 ** zoom > boxSize in both X and Y.
      // BUT we need the minimum zoom to have at least gridSize, i.e.,
      // min zoom = log2(gridSize).
      var zoomX = Math.log2( Math.max(gridSize.x, (gridSize.x - 1) / boxWidth) );
      var zoomY = Math.log2( Math.max(gridSize.y, (gridSize.y - 1) / boxHeight) );
      zoom = Math.floor( Math.min(zoomX, zoomY) );
      zoom = Math.min(zoom, maxZoom);
      nTiles = 2 ** zoom; // Number of tiles at this zoom level

      // 2. Compute the tile indices of the center of the box
      var centerX = (p1[0] + boxWidth / 2.0) * nTiles;
      if (centerX > nTiles) centerX -= nTiles;
      var centerY = 0.5 * (p1[1] + p2[1]) * nTiles;

      // 3. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      xTile0 = Math.round(centerX - gridSize.x / 2.0);
      xTile0 = wrap(xTile0, nTiles); // in case we crossed the antimeridian
      yTile0 = Math.round(centerY - gridSize.y / 2.0);
      // Don't let box cross poles
      yTile0 = Math.min(Math.max(0, yTile0), nTiles - gridSize.y);

      // Return a flag indicating whether map parameters were updated
      if (zoom !== oldZ || xTile0 !== oldX || yTile0 !== oldY) {
        updateTransform();
        return true;
      }
      return false;
    }

    function pan(dx, dy) {
      xTile0 = wrap(xTile0 + dx, nTiles);
      yTile0 = wrap(yTile0 + dy, nTiles);
      updateTransform();
      return (dx || dy);
    }

    function zoomIn() {
      if (zoom > maxZoom - 1) return false;
      zoom++;
      xTile0 = Math.floor(2 * xTile0 + gridSize.x / 2.0);
      yTile0 = Math.floor(2 * yTile0 + gridSize.y / 2.0);
      updateTransform();
      return true;
    }

    function zoomOut() {
      if (zoom < 1) return false;
      zoom--;
      xTile0 = Math.ceil( (xTile0 - gridSize.x / 2.0) / 2 );
      yTile0 = Math.ceil( (yTile0 - gridSize.y / 2.0) / 2 );
      updateTransform();
      return true;
    }

  }

  function wrap(x, xmax) {
    while (x < 0) x += xmax;
    while (x >= xmax) x -= xmax;
    return x;
  }

  function initTiles(tileAPI) {
    const size = tileAPI.tileSize;

    // Initialize the tiles object
    const tiles = {};

    // Return methods for accessing and updating the tiles
    return {
      retrieve,
      prune,
    };

    //function retrieve(tile, z, x, y) {
    function retrieve(tile, zxy) {
      tile.found = false;
      getTileOrParent(tile, zxy[0], zxy[1], zxy[2], 0, 0, size);
      // Return a flag indicating whether we have an image ready
      return tile.found;
    }

    function getTileOrParent(
        tileObj,     // Returned tile object
        z, x, y,     // Coordinates of the requested tile
        sx, sy, sw   // Cropping parameters--which part of the tile to use
        ) {

      // Retrieve the specified tile from the tiles object
      let tileID = tileAPI.getID(z, x, y);
      let tile = tiles[tileID];

      // If the tile exists and is ready, return it with cropping info
      if (tile && tile.complete && tile.naturalWidth !== 0) {
        tileObj.img = tile;
        tileObj.sx = sx;
        tileObj.sy = sy;
        tileObj.sw = sw;
        tileObj.found = true;
        return;
      }

      // Looks like the tile wasn't ready. Try using the parent tile
      if (z > 0 && sw > 1) { // Don't look too far back
        // Get coordinates and cropping parameters of the parent
        let pz = z - 1;
        let px = Math.floor(x / 2);
        let py = Math.floor(y / 2);
        let psx = sx / 2 + (x / 2 - px) * size;
        let psy = sy / 2 + (y / 2 - py) * size;
        let psw = sw / 2;

        getTileOrParent(tileObj, pz, px, py, psx, psy, psw); // recursive call!
      }

      if (!tile) {  // Tile didn't exist. Create it and request image from API
        tile = new Image();
        tile.zoom = z;
        tile.indx = x;
        tile.indy = y;
        tile.crossOrigin = "anonymous";
        tile.src = tileAPI.getURL(tileID);
        tiles[tileID] = tile;
      }

      return;
    }

    function prune(metric, threshold) {
      // Remove tiles far from current view (as measured by metric)

      for ( let id in tiles ) {
        let distance = metric(tiles[id].zoom, tiles[id].indx, tiles[id].indy);
        if (distance >= threshold) {
          tiles[id].src = ""; // Cancel any outstanding request (is it necessary?)
          delete tiles[id];
        }
      }
      return;
    }

  }

  function initMap2D(display, overlay, tileAPI, projection) {
    // Setup tile coordinates  TODO: tileAPI should include projection?
    const tileCoords = initTileCoords( tileAPI, projection );
    const size = tileAPI.tileSize;

    // Set canvas drawing buffer size equal to the CSS displayed size
    const mapWidth = tileCoords.gridSize.x * size;
    const mapHeight = tileCoords.gridSize.y * size;
    display.canvas.width = mapWidth;
    display.canvas.height = mapHeight;
    overlay.canvas.width = mapWidth;
    overlay.canvas.height = mapHeight;
    console.log("display size: " + mapWidth + "x" + mapHeight);

    const tiles = initTiles(tileAPI);

    // Initialize tracking object, to check if map needs to be updated
    const dz = [];
    for (let iy = 0; iy < tileCoords.gridSize.y; iy++) {
      dz[iy] = [];
      for (let ix = 0; ix < tileCoords.gridSize.x; ix++) {
        // dz indicates the difference between the requested zoom level
        // and the zoom level actually written to this tile
        dz[iy][ix] = tileAPI.maxZoom;
      }
    }
    const oneTileComplete = 1. / tileCoords.gridSize.x / tileCoords.gridSize.y;
    const mapStatus = {
      complete: 0.0,
      dz,
      reset: function() {
        this.complete = 0.0;
        for (let iy = 0; iy < tileCoords.gridSize.y; iy++) {
          for (let ix = 0; ix < tileCoords.gridSize.x; ix++) {
            dz[iy][ix] = tileAPI.maxZoom;
          }
        }
        return;
      },
    };

    function drawTiles() {
      // Quick exit if map is already complete.
      if ( mapStatus.complete === 1.0 ) return false; // No change!

      // Loop over tiles in the map
      const tileObj = {};
      const zxy = [];
      for (let iy = 0; iy < tileCoords.gridSize.y; iy++) {
        for (let ix = 0; ix < tileCoords.gridSize.x; ix++) {
          if (mapStatus.dz[iy][ix] === 0) continue; // This tile already done

          tileCoords.getZXY(zxy, ix, iy);
          //console.log("drawTiles: zxy = " + zxy);
          var foundTile = tiles.retrieve( tileObj, zxy );
          if (!foundTile) continue; // No image available for this tile
          //console.log("drawTiles: zxy=" + zxy + "  " + tileObj
          var dzTmp = zxy[0] - tileObj.img.zoom;
          if (dzTmp == mapStatus.dz[iy][ix]) continue; // Tile already written

          display.drawImage(
              tileObj.img,    // Image to read, and paint to the canvas
              tileObj.sx,     // First x-pixel in tile to read
              tileObj.sy,     // First y-pixel in tile to read
              tileObj.sw,     // Number of pixels to read in x
              tileObj.sw,     // Number of pixels to read in y
              ix * size,      // First x-pixel in canvas to paint
              iy * size,      // First y-pixel in canvas to paint
              size,           // Number of pixels to paint in x
              size            // Number of pixels to paint in y
              );

          if (dzTmp == 0) mapStatus.complete += oneTileComplete;
          mapStatus.dz[iy][ix] = dzTmp;
        }
      }
      // Clean up -- don't let images object get too big
      tiles.prune(tileCoords.tileDistance, 3.5);
      return true; // Map has updated or is not yet complete
    }

    // Return methods for drawing a 2D map
    return {
      pan,
      zoomIn,
      zoomOut,
      fitBoundingBox,
      drawTiles,
      loaded: function() {
        return mapStatus.complete;
      },
    };

    function pan(dx, dy) {
      var changed = tileCoords.pan(dx, dy);
      if (changed) reset();
    }

    function zoomIn() {
      var changed = tileCoords.zoomIn();
      if (changed) reset();
    }

    function zoomOut() {
      var changed = tileCoords.zoomOut();
      if (changed) reset();
    }

    function fitBoundingBox(p1, p2) {
      var changed = tileCoords.fitBoundingBox(p1, p2);
      if (changed) reset();
    }

    function reset() {
      // Reset map status
      mapStatus.reset();
      // Clear canvases
      display.clearRect(0, 0, mapWidth, mapHeight);
      overlay.clearRect(0, 0, mapWidth, mapHeight);
      return;
    }

  }

  const params = {
    baseURL: "https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/",
    token: "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA",
    tileSize: 256, //512,
    maxZoom: 20,
    getID: function(zoom, x, y) {
      return "/" + zoom + "/" + x + "/" + y + "/";
    },
    getURL: function(id) {
      return this.baseURL + this.tileSize + id + "?access_token=" + this.token;
    },
  };
  // Export as read-only
  const tileAPI = Object.freeze(params);

  function initMercator() {
    // Maximum latitude for Web Mercator: 85.0113 degrees. Beware rounding!
    const maxMercLat = 2.0 * Math.atan( Math.exp(Math.PI) ) - Math.PI / 2.0;

    const shaderParams = new Float64Array(2);

    return {
      lonLatToXY,
      lonToX,
      latToY,
      setShaderParams,
      shaderParams,
    };

    function setShaderParams(lat) {
      // Clip latitude to map boundaries
      var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);

      // camera exp(Y), for converting delta latitude to delta Y
      shaderParams[0] = Math.tan( 0.25 * Math.PI + 0.5 * clipLat );

      // Difference of clipping
      shaderParams[1] = lat - clipLat;
      return;
    }

    function lonLatToXY(projected, geodetic) {
      // Input geodetic is a pointer to a 2- (or 3?)-element array, containing
      // longitude and latitude of a point on the ellipsoid surface
      // Output projected is a pointer to a 2-element array containing
      // the projected X/Y coordinates

      projected[0] = lonToX( geodetic[0] );
      projected[1] = latToY( geodetic[1] );
      return;
    }

    function lonToX(lon) {
      // Convert input longitude in radians to a Web Mercator x-coordinate
      // where x = 0 at lon = -PI, x = 1 at lon = +PI
      return 0.5 + 0.5 * lon / Math.PI;
    }

    function latToY(lat) {
      // Convert input latitude in radians to a Web Mercator y-coordinate
      // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
      var clipLat = Math.min(Math.max(-maxMercLat, lat), maxMercLat);
      var y = 0.5 - 0.5 / Math.PI * // Note sign flip;
        Math.log( Math.tan(Math.PI / 4.0 + clipLat / 2.0) );
      // Clip range to [0,1], since y does not wrap around
      return Math.min(Math.max(0.0, y), 1.0);
    }
  }

  function main() {
    // Setup 2D map
    const display = document.getElementById("rasterCanvas").getContext("2d");
    const overlay = document.getElementById("vectorCanvas").getContext("2d");
    const projection = initMercator();
    const map = initMap2D(display, overlay, tileAPI, projection);

    // Handle a supplied bounding box
    var westDeg = document.getElementById("west");
    var eastDeg = document.getElementById("east");
    var northDeg = document.getElementById("north");
    var southDeg = document.getElementById("south");
    var bboxSet = document.getElementById("bboxSet");
    bboxSet.addEventListener("click", function(click) {
      var p1 = [
        projection.lonToX( toRadians(westDeg.value) ),
        projection.latToY( toRadians(northDeg.value) )
      ];
      var p2 = [
        projection.lonToX( toRadians(eastDeg.value) ),
        projection.latToY( toRadians(southDeg.value) )
      ];
      map.fitBoundingBox(p1, p2);
    }, false);

    function toRadians(degrees) {
      return degrees * Math.PI / 180.0;
    }
    // Setup panning controls
    var up = document.getElementById("up");
    up.addEventListener("click", function(click) { map.pan(0, -1); }, false);
    var down = document.getElementById("down");
    down.addEventListener("click", function(click) { map.pan(0, 1); }, false);
    var left = document.getElementById("left");
    left.addEventListener("click", function(click) { map.pan(-1, 0); }, false);
    var right = document.getElementById("right");
    right.addEventListener("click", function(click) { map.pan(1, 0); }, false);

    // Setup zoom controls
    var zoomIn = document.getElementById("zoomIn");
    zoomIn.addEventListener("click", function(click) { map.zoomIn(); }, false);
    var zoomOut = document.getElementById("zoomOut");
    zoomOut.addEventListener("click", function(click) { map.zoomOut(); }, false);

    // Track loading status
    var loaded = document.getElementById("completion");
    // Start animation loop
    requestAnimationFrame(checkRender);
    function checkRender(time) {
      map.drawTiles();
      var percent = map.loaded() * 100;
      if (percent < 100) {
        loaded.innerHTML = "Loading: " + percent.toFixed(0) + "%";
      } else {
        loaded.innerHTML = "Complete! " + percent.toFixed(0) + "%";
      }
      requestAnimationFrame(checkRender);
    }
  }

  exports.main = main;

  return exports;

}({}));
