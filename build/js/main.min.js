var rasterMap = (function (exports) {
  'use strict';

  function initTiledTexture(gl, numTilesX, numTilesY, tileSize) {
    // Create the texture object
    const texture = gl.createTexture();
    // Bind to the 2D target in the WebGL context
    gl.bindTexture(gl.TEXTURE_2D, texture);

    // Define parameters
    const level = 0;
    const internalFormat = gl.RGBA;
    const width = numTilesX * tileSize;
    const height = numTilesY * tileSize;
    const border = 0;
    const srcFormat = gl.RGBA;
    const srcType = gl.UNSIGNED_BYTE;

    // Create a blank dummy image
    //const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
    const dummy = new Uint8Array( 4 * width * height );

    // Initialize the texture using defined parameters and dummy image
    gl.texImage2D( gl.TEXTURE_2D, level, internalFormat,
        width, height, border, srcFormat, srcType, dummy );

    // Set up mipmapping and anisotropic filtering, if appropriate
    setupMipMaps(gl, gl.TEXTURE_2D, width, height);
    setTextureAnisotropy(gl, gl.TEXTURE_2D);

    // Save a link to the WebGL rendering context, for use in updateTextureTile()
    const glSave = gl;

    // Define the method for loading an image tile to this texture
    function updateTextureTile() {
      // We don't know what happened re: binding points between the
      // initialization of the texture and the invocation of this method.
      // Hence we re-bind the texture to the 2D target (binding point)
      glSave.bindTexture( glSave.TEXTURE_2D, texture );

      // updateTiledTexture will have been assigned as a method of an image 
      // object, so 'this' is an image to which has been added the additional
      // properties xoffset and yoffset specifying the positioning of the image
      // relative to the origin of the texture
      glSave.texSubImage2D( glSave.TEXTURE_2D, level, 
          this.xoffset, this.yoffset, srcFormat, srcType, this );
    }

    return {
      sampler: texture,
      updateTile: updateTextureTile
    };
  }

  function setupMipMaps(gl, target, width, height) {
    // On mobile browsers, we might still be using WebGL1.
    // WebGL1 can't handle mipmapping for non-power-of-2 images
    // (not sure if this limitation applies to externally provided mipmaps)
    // For external mips, see https://stackoverflow.com/a/21540856/10082269
    if (isPowerOf2(width) && isPowerOf2(height)) {
      gl.generateMipmap(target);
    } else { // Turn off mipmapping 
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // Set wrapping to clamp to edge
      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    return;
  }

  function setTextureAnisotropy(gl, target) {
    var ext = (
        gl.getExtension('EXT_texture_filter_anisotropic') ||
        gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || 
        gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        );
    if (ext) {
      var maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, 
          maxAnisotropy);
    }
    return;
  }

  function isPowerOf2(value) {
    // This trick uses bitwise operators.
    // See https://stackoverflow.com/a/30924333/10082269
    return value && !(value & (value - 1));
    // For a better explanation, with some errors in the solution, see
    // https://stackoverflow.com/a/30924360/10082269
  }

  function initMap2D(rasterContext, vectorContext) {
    // Define some parameters for a tiled map texture
    const tmsRoot = "https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/";
    const token = "pk.eyJ1IjoiamhlbWJkIiwiYSI6ImNqcHpueHpyZjBlMjAzeG9kNG9oNzI2NTYifQ.K7fqhk2Z2YZ8NIV94M-5nA";
    const tileSize = 256;
    const numTilesX = 4;
    const numTilesY = 3;
    const display = rasterContext;
    const overlay = vectorContext;

    // Set canvas drawing buffer size equal to the CSS displayed size
    display.canvas.width = display.canvas.clientWidth;
    display.canvas.height = display.canvas.clientHeight;
    overlay.canvas.width = display.canvas.clientWidth;
    overlay.canvas.height = display.canvas.clientHeight;
    console.log("display size: " + display.canvas.width + 
        "x" + display.canvas.height);

    // Initialize the WebGL texture
    const tileTex = initTiledTexture(display, numTilesX, numTilesY, tileSize);

    // Return methods for updating the tiles, along with the texture sampler
    return {
      boundingBoxToZXY,
      xyToMapPixels,
      drawTiles,
      sampler: tileTex.sampler,
    };

    // TODO: automatically redraw tiles IF zoom,x0,y0 change to fit bounding box
    function boundingBoxToZXY(x1, y1, x2, y2) {
      // Inputs x1,y1, x2,y2 are Web Mercator coordinates in the range 
      // [0,1] X [0,1] with (0,0) at the top left corner.
      // ASSUMES (x2,y2) is SouthEast of (x1,y1) although we may have x2 < x1
      // if the box crosses the antimeridian (longitude = +/- PI)

      // 1. Calculate the maximum zoom level at which the bounding box will fit
      // within the map. Note: we want to be able to pan without having to change
      // zoom. Hence the bounding box must always fit within numTiles - 1.
      // (allows panning to where x1 is near the right edge of a tile.)

      // Compute box width and height, with special handling for antimeridian
      var boxWidth = x2 - x1;
      if (boxWidth < 0) boxWidth += 1.0; // Crossing antimeridian
      if (boxWidth > 0.5) return false;  // x1 and x2 are flipped?
      var boxHeight = y2 - y1;
      if (boxHeight < 0) return false;

      //console.log("boundingBox: box width,height = " + boxWidth + "," + boxHeight);

      // Width/height of a tile: 1 / 2 ** zoom. Hence we need
      //  (numTiles? - 1) / 2 ** zoom > boxSize in both X and Y.
      var zoomX = Math.log2( (numTilesX - 1) / boxWidth );
      var zoomY = Math.log2( (numTilesY - 1) / boxHeight );
      var zoom = Math.floor( Math.min(zoomX, zoomY) );

      //console.log("boundingBox: zoom = " + zoom);

      var imax = 2 ** zoom; // Number of tiles at this zoom level

      // 2. Compute the tile indices of the center of the box
      // WHY didn't this fail with undefined variables?
      var centerX = (x1 + boxWidth / 2.0) * imax;
      if (centerX > imax) centerX -= imax;
      var centerY = 0.5 * (y1 + y2) * imax;
      //console.log("Box center X,Y = " + centerX + "," + centerY);

      // 3. Find the integer tile numbers of the top left corner of the rectangle
      //    whose center will be within 1/2 tile of (centerX, centerY)
      var x0 = Math.round(centerX - numTilesX / 2.0);
      x0 = wrap(x0, imax);  // in case we pushed x0 back across the antimeridian
      var y0 = Math.round(centerY - numTilesY / 2.0);

      return { zoom, x0, y0 };
    }

    function xyToMapPixels(webMercX, webMercY, zoom, x0, y0) {
      var imax = 2 ** zoom; // Number of tiles at this zoom level

      // Convert input point to fractional number of tiles from x0, y0
      var rx = webMercX * imax - x0;
      if (rx < 0) rx += imax; // Crossed longitude = 180
      if (rx > numTilesX) return false; // Outside the map!
      var ry = webMercY * imax - y0;
      if (ry < 0 || ry > numTilesY) return false; // Outside the map!

      return { // Convert to number of pixels
        x: rx * tileSize, 
        y: ry * tileSize,
      };
    }

    function drawTiles(zoom, x0, y0) {
      overlay.clearRect(0, 0, overlay.canvas.width, overlay.canvas.height);
      var imax = 2 ** zoom;
      // Load tiles and draw on canvas.
      // Note: could return images array instead of drawing on canvas?
      const images = [];
      for (let iy = 0; iy < numTilesY; iy++) {
        images[iy] = [];
        var y = wrap(y0 + iy, imax);
        var ypx = iy * tileSize;

        for (let ix = 0; ix < numTilesX; ix++) {
          images[iy][ix] = new Image();
          var x = wrap(x0 + ix, imax);
          var zxyString = "/" + zoom + "/" + x + "/" + y + "/";
          //console.log("zxyString: " + zxyString);

          images[iy][ix].xoffset = ix * tileSize;
          images[iy][ix].yoffset = ypx;
          //images[iy][ix].onload = drawTile;
          images[iy][ix].onload = tileTex.updateTile;
          images[iy][ix].crossOrigin = "anonymous";
          images[iy][ix].src = tmsRoot + tileSize + zxyString + 
            "?access_token=" + token;
        }
      }
    }

    //function drawTile() {
    //  display.drawImage(this, this.xpx, this.ypx);
    //}
  }

  function wrap(x, xmax) {
    while (x < 0) {
      x += xmax;
    }
    while (x >= xmax) {
      x -= xmax;
    }
    return x;
  }

  function lonToWebMercX(lon) {
    // Convert input longitude in radians to a Web Mercator x-coordinate
    // where x = 0 at lon = -PI, x = 1 at lon = +PI
    return 0.5 + 0.5 * lon / Math.PI;
  }

  function latToWebMercY(lat) {
    // Convert input latitude in radians to a Web Mercator y-coordinate
    // where y = 0 at lat = 85.05113 deg, y = 1 at lat = -85.05113 deg
    return 0.5 - 0.5 / Math.PI * // Note sign flip
      Math.log( Math.tan(Math.PI / 4 + lat / 2.0) ); // This term is in [-PI,PI]
  }

  const vertexSrc = `
  attribute vec4 aVertexPosition;
  attribute vec2 aTexCoord;

  varying highp vec2 vTexCoord;

  void main(void) {
    vTexCoord = aTexCoord;
    gl_Position = aVertexPosition;
  }
`;

  const fragmentSrc = `
  varying highp vec2 vTexCoord;

  uniform sampler2D uTextureSampler;

  void main(void) {
    gl_FragColor = texture2D(uTextureSampler, vTexCoord);
  }
`;

  // Very similar to greggman's module:
  // https://github.com/greggman/webgl-fundamentals/blob/master/webgl/resources/webgl-utils.js
  function createAttributeSetters(gl, program) {
    var attribSetters = {};
    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttribs; i++) {
      var attribInfo = gl.getActiveAttrib(program, i);
      if (!attribInfo) break;
      var index = gl.getAttribLocation(program, attribInfo.name);
      attribSetters[attribInfo.name] = createAttribSetter(gl, index);
    }
    return attribSetters;
  }

  function createAttribSetter(gl, index) {
    return function(b) {
      // Enable this attribute (shader attributes are disabled by default)
      gl.enableVertexAttribArray(index);
      // Bind the buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
      // Point the attribute in the program to this buffer,
      // and tell the program the byte layout in the buffer
      gl.vertexAttribPointer(
          index,                      // index of attribute in program
          b.numComponents || b.size,  // Number of elements to read per vertex
          b.type || gl.FLOAT,         // Type of each element
          b.normalize || false,       // Whether to normalize it
          b.stride || 0,              // Byte spacing between vertices
          b.offset || 0               // Byte # to start reading from
          );
    };
  }

  function setBuffersAndAttributes(gl, setters, buffers) {
    setAttributes(setters, buffers.attributes);
    if (buffers.indices) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices.buffer);
    }
  }

  function setAttributes(setters, attribs) {
    Object.keys(attribs).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter( attribs[name] );
    });
  }

  // Very similar to greggman's module:
  // https://github.com/greggman/webgl-fundamentals/blob/master/webgl/resources/webgl-utils.js
  function createUniformSetters(gl, program) {

    var uniformSetters = {};
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

    // Track texture bindpoint index in case multiple textures are required
    var textureUnit = 0;

    for (let i = 0; i < numUniforms; i++) {
      var uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) break;

      var name = uniformInfo.name;
      // remove the array suffix added by getActiveUniform
      if (name.substr(-3) === "[0]") {
        name = name.substr(0, name.length - 3);
      }
      var setter = createUniformSetter(program, uniformInfo);
      uniformSetters[name] = setter;
    }
    return uniformSetters;

    // This function must be nested to access the textureUnit index
    function createUniformSetter(program, uniformInfo) {
      var location = gl.getUniformLocation(program, uniformInfo.name);
      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
      var type = uniformInfo.type;
      switch (type) {
        case gl.FLOAT :
          if (isArray) {
            return function(v) { gl.uniform1fv(location, v); };
          } else {
            return function(v) { gl.uniform1f(location, v); };
          }
        case gl.FLOAT_VEC2 :
          return function(v) { gl.uniform2fv(location, v); };
        case gl.FLOAT_VEC3 :
          return function(v) { gl.uniform3fv(location, v); };
        case gl.FLOAT_VEC4 :
          return function(v) { gl.uniform4fv(location, v); };
        case gl.INT :
          if (isArray) {
            return function(v) { gl.uniform1iv(location, v); };
          } else {
            return function(v) { gl.uniform1i(location, v); };
          }
        case gl.INT_VEC2 :
          return function(v) { gl.uniform2iv(location, v); };
        case gl.INT_VEC3 :
          return function(v) { gl.uniform3iv(location, v); };
        case gl.INT_VEC4 :
          return function(v) { gl.uniform4iv(location, v); };
        case gl.BOOL :
          return function(v) { gl.uniform1iv(location, v); };
        case gl.BOOL_VEC2 :
          return function(v) { gl.uniform2iv(location, v); };
        case gl.BOOL_VEC3 :
          return function(v) { gl.uniform3iv(location, v); };
        case gl.BOOL_VEC4 :
          return function(v) { gl.uniform4iv(location, v); };
        case gl.FLOAT_MAT2 :
          return function(v) { gl.uniformMatrix2fv(location, false, v); };
        case gl.FLOAT_MAT3 :
          return function(v) { gl.uniformMatrix3fv(location, false, v); };
        case gl.FLOAT_MAT4 :
          return function(v) { gl.uniformMatrix4fv(location, false, v); };
        case gl.SAMPLER_2D :
        case gl.SAMPLER_CUBE :
          if (isArray) {
            var units = [];
            for (let i = 0; i < uniformInfo.size; i++) { // greggman wrong here!
              units.push(textureUnit++);
            }
            return function(bindPoint, units) {
              return function(textures) {
                gl.uniform1iv(location, units);
                textures.forEach( function(texture, index) {
                  gl.activeTexture(gl.TEXTURE0 + units[index]);
                  gl.bindTexture(bindPoint, texture);
                });
              };
            }(getBindPointForSamplerType(gl, type), units);
          } else {
            return function(bindPoint, unit) {
              return function(texture) {
                //gl.uniform1i(location, units); // Typo? How did it even work?
                gl.uniform1i(location, unit);
                gl.activeTexture(gl.TEXTURE0 + unit);
                gl.bindTexture(bindPoint, texture);
              };
            }(getBindPointForSamplerType(gl, type), textureUnit++);
          }
       default:  // we should never get here
          throw("unknown type: 0x" + type.toString(16));
      }
    }
  }

  function getBindPointForSamplerType(gl, type) {
    if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;
    if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;
    return undefined;
  }

  function setUniforms(setters, values) {
    Object.keys(values).forEach( function(name) {
      var setter = setters[name];
      if (setter) setter(values[name]);
    });
  }

  // Initialize a shader program
  function initShaderProgram(gl, vsSource, fsSource) {
    // Load extensions
    // ERROR: doesn't work here, but works if loaded right after .getContext ?!?
    //gl.getExtension('OES_standard_derivatives');

    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      alert( 'Unable to initialize the shader program: \n' +
          gl.getProgramInfoLog(shaderProgram) );
      // This is not very good error handling... should be returning the error
      return null;
    }

    return {
      program: shaderProgram,
      attributeSetters: createAttributeSetters(gl, shaderProgram),
      uniformSetters: createUniformSetters(gl,shaderProgram),
    };
  }

  // create shader of a given type, upload source, compile it
  function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    // no error handling for createShader??

    // Send the source to the shader object
    gl.shaderSource(shader, source);

    // Compile the shader program
    gl.compileShader(shader);

    // Now check for errors
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      // this alert business is sloppy...
      alert( 'An error occurred compiling the shaders: \n' +
          gl.getShaderInfoLog(shader) );
      gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  function drawScene( gl, programInfo, bufferInfo, uniforms ) {
    // Make a blank canvas that fills the displayed size from CSS
    prepCanvas(gl);

    // Tell WebGL to use our program when drawing
    gl.useProgram(programInfo.program);

    // Prepare shader attributes.
    setBuffersAndAttributes( gl, programInfo.attributeSetters, bufferInfo );
    // Set the shader uniforms
    setUniforms( programInfo.uniformSetters, uniforms );

    // Draw the scene
    gl.drawElements(gl.TRIANGLES, bufferInfo.indices.vertexCount,
        bufferInfo.indices.type, bufferInfo.indices.offset);
  }

  function prepCanvas(gl) {
    // Set some parameters
    gl.clearColor(1.0, 0.0, 0.0, 1.0);  // Clear to solid red
    gl.clearDepth(1.0);                 // Clear everything
    gl.enable(gl.DEPTH_TEST);           // Enable depth testing
    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // Clear the canvas AND the depth buffer
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    return;
  }

  function initBuffers(gl) {
    // 4 vertices at the corners of the screen
    const vertices = [
      -1, -1,  0,    1, -1,  0,    1,  1,  0,   -1,  1,  0
    ];

    // Texture coordinates assume image has 0,0 at top left
    const texCoordData = [
      0, 1,   1, 1,   1, 0,   0, 0
    ];

    // Index into two triangles
    var indices = [
       0,  1,  2,    2,  3,  0
    ];

    // Store byte info and load into GPU
    const vertexPositions = {
      buffer: gl.createBuffer(),
      numComponents: 3,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    // Bind to the gl context
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositions.buffer);
    // Pass the array into WebGL
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    const texCoords = {
      buffer: gl.createBuffer(),
      numComponents: 2,
      type: gl.FLOAT,
      normalize: false,
      stride: 0,
      offset: 0
    };
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoords.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoordData), gl.STATIC_DRAW);

    const vertexIndices = {
      buffer: gl.createBuffer(),
      vertexCount: indices.length,
      type: gl.UNSIGNED_SHORT,
      offset: 0
    };
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vertexIndices.buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    // Note: unlike in ../../globe/src/initBuffers.js, we do not initialize the
    // textures here. The texture sampler is set as a uniform, so we never really
    // need the texture in the bufferInfo object.
    // In this case, initializing a tiled texture returns both a sampler and a
    // method to update tiles. Putting all this in bufferInfo would be
    // unnecessarily messy.
    
    return {
      attributes: {
        aVertexPosition: vertexPositions,
        aTexCoord: texCoords,
      },
      indices: vertexIndices,
    };
  }

  function main() {

    // Set initial values. TODO: make these properties of the map object?
    var x0 = 1;
    var y0 = 0;
    var zoom = 1;

    // Get graphics contexts for canvases
    // WebGL canvas for drawing raster tiles
    const rasterCanvas = document.getElementById("rasterCanvas");
    //var display = rasterCanvas.getContext("2d", { premultipliedAlpha: false });
    var display = rasterCanvas.getContext("webgl", { premultipliedAlpha: false });
    // 2D canvas for vector overlays
    const vectorCanvas = document.getElementById("vectorCanvas");
    var overlay = vectorCanvas.getContext("2d");

    // Initialize shaders
    const progInfo = initShaderProgram(display, 
        vertexSrc, fragmentSrc);
    // Load data into GPU for shaders: vertices, texture coordinates, indices
    const bufferInfo = initBuffers(display);

    // Initialize tiled map texture, with methods to update zoom and pan
    // TODO: add callback to set needToRender at every update of the texture
    var map = initMap2D(display, overlay);

    // Initialize shader uniforms
    const uniformValues = {
      uTextureSampler: map.sampler,
    };

    // Load tiles to the texture for the initial map
    map.drawTiles(zoom, x0, y0);

    // TODO: For all the below event listeners, we could move them to a separate
    // module IF zoom, x0, y0 were all properties of the map object.
    // Handle a supplied bounding box
    var westDeg = document.getElementById("west");
    var eastDeg = document.getElementById("east");
    var northDeg = document.getElementById("north");
    var southDeg = document.getElementById("south");
    var bboxSet = document.getElementById("bboxSet");
    bboxSet.addEventListener("click", function(click) {
      var x1 = lonToWebMercX( toRadians(westDeg.value) );
      var y1 = latToWebMercY( toRadians(northDeg.value) );
      var x2 = lonToWebMercX( toRadians(eastDeg.value) );
      var y2 = latToWebMercY( toRadians(southDeg.value) );
      //console.log("x1,y1  x2,y2 = " + x1 + "," + y1 + "  " + x2 + "," + y2);
      var bboxZXY = map.boundingBoxToZXY(x1, y1, x2, y2);
      if (!bboxZXY) {
        console.log("ERROR: Failed to define map containing this bounding box");
        return;
      }
      zoom = bboxZXY.zoom;
      x0 = bboxZXY.x0;
      y0 = bboxZXY.y0;
      map.drawTiles(zoom, x0, y0);
      // Draw the bounding box on the map
      var pix1 = map.xyToMapPixels(x1, y1, zoom, x0, y0);
      var pix2 = map.xyToMapPixels(x2, y2, zoom, x0, y0);
      overlay.strokeStyle = "#FF0000";
      overlay.strokeRect(pix1.x, pix1.y, pix2.x - pix1.x, pix2.y - pix1.y);
    }, false);

    function toRadians(degrees) {
      return degrees * Math.PI / 180.0;
    }
    // Setup panning controls
    var up = document.getElementById("up");
    up.addEventListener("click", function(click) {
      y0--;
      map.drawTiles(zoom, x0, y0);
    }, false);
    var down = document.getElementById("down");
    down.addEventListener("click", function(click) {
      y0++;
      map.drawTiles(zoom, x0, y0);
    }, false);
    var left = document.getElementById("left");
    left.addEventListener("click", function(click) {
      x0--;
      map.drawTiles(zoom, x0, y0);
    }, false);
    var right = document.getElementById("right");
    right.addEventListener("click", function(click) {
      x0++;
      map.drawTiles(zoom, x0, y0);
    }, false);

    // Setup zoom controls
    var zoomIn = document.getElementById("zoomIn");
    zoomIn.addEventListener("click", function(click) {
      //zoom = Math.min(zoom + 1, maxZoom);
      zoom++;
      x0 = 2 * x0 + 2; // TODO: these formula depend on numX, numY
      y0 = 2 * y0 + 1;
      map.drawTiles(zoom, x0, y0);
    }, false);
    var zoomOut = document.getElementById("zoomOut");
    zoomOut.addEventListener("click", function(click) {
      //zoom = Math.max(zoom - 1, minZoom);
      zoom--;
      x0 = Math.ceil( (x0 - 2) / 2 );
      y0 = Math.ceil( (y0 - 1) / 2 );
      map.drawTiles(zoom, x0, y0);
    }, false);

    requestAnimationFrame(checkRender);

    function checkRender(time) {
      drawScene(display, progInfo, bufferInfo, uniformValues);
      requestAnimationFrame(checkRender);
    }
  }

  exports.main = main;

  return exports;

}({}));
